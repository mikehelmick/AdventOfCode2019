package main

import (
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/mikehelmick/adventofcode2019/computer"
)

type pos struct {
	x, y int
}

type dir pos

func (d dir) turnLeft() dir {
	switch d {
	case dir{-1, 0}:
		return dir{0, -1}
	case dir{1, 0}:
		return dir{0, 1}
	case dir{0, -1}:
		return dir{1, 0}
	default: // dir{0, 1}:
		return dir{-1, 0}
	}
}

func (d dir) turnRight() dir {
	switch d {
	case dir{-1, 0}:
		return dir{0, 1}
	case dir{1, 0}:
		return dir{0, -1}
	case dir{0, 1}:
		return dir{1, 0}
	default: // dir{0, 1}:
		return dir{-1, 0}
	}
}

func (p *pos) move(d dir) {
	p.x += d.x
	p.y += d.y
}

func main() {
	input := "3,8,1005,8,328,1106,0,11,0,0,0,104,1,104,0,3,8,102,-1,8,10,1001,10,1,10,4,10,108,0,8,10,4,10,1002,8,1,28,1,1003,10,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,102,1,8,54,2,1103,6,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,0,8,10,4,10,101,0,8,80,3,8,1002,8,-1,10,1001,10,1,10,4,10,108,1,8,10,4,10,1002,8,1,102,3,8,102,-1,8,10,1001,10,1,10,4,10,108,0,8,10,4,10,1001,8,0,124,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,1,10,4,10,1001,8,0,147,1006,0,35,1,7,3,10,2,106,13,10,2,1104,9,10,3,8,102,-1,8,10,1001,10,1,10,4,10,108,0,8,10,4,10,1002,8,1,183,2,7,16,10,2,105,14,10,1,1002,12,10,1006,0,13,3,8,102,-1,8,10,1001,10,1,10,4,10,108,0,8,10,4,10,1002,8,1,220,1006,0,78,2,5,3,10,1006,0,92,1006,0,92,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,1001,8,0,255,1006,0,57,2,1001,11,10,1006,0,34,2,1007,18,10,3,8,1002,8,-1,10,101,1,10,10,4,10,1008,8,1,10,4,10,1002,8,1,292,2,109,3,10,1,1103,14,10,2,2,5,10,2,1006,3,10,101,1,9,9,1007,9,997,10,1005,10,15,99,109,650,104,0,104,1,21101,932700762920,0,1,21101,0,345,0,1105,1,449,21102,1,386577306516,1,21102,356,1,0,1106,0,449,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,21101,179355975827,0,1,21101,403,0,0,1106,0,449,21102,1,46413220903,1,21102,1,414,0,1106,0,449,3,10,104,0,104,0,3,10,104,0,104,0,21101,988224959252,0,1,21102,1,437,0,1106,0,449,21101,717637968660,0,1,21101,0,448,0,1106,0,449,99,109,2,22101,0,-1,1,21102,40,1,2,21101,480,0,3,21101,470,0,0,1106,0,513,109,-2,2105,1,0,0,1,0,0,1,109,2,3,10,204,-1,1001,475,476,491,4,0,1001,475,1,475,108,4,475,10,1006,10,507,1102,1,0,475,109,-2,2105,1,0,0,109,4,2102,1,-1,512,1207,-3,0,10,1006,10,530,21102,1,0,-3,22102,1,-3,1,22101,0,-2,2,21102,1,1,3,21101,0,549,0,1105,1,554,109,-4,2105,1,0,109,5,1207,-3,1,10,1006,10,577,2207,-4,-2,10,1006,10,577,21202,-4,1,-4,1106,0,645,21202,-4,1,1,21201,-3,-1,2,21202,-2,2,3,21102,1,596,0,1106,0,554,21201,1,0,-4,21101,1,0,-1,2207,-4,-2,10,1006,10,615,21101,0,0,-1,22202,-2,-1,-2,2107,0,-3,10,1006,10,637,21201,-1,0,1,21101,0,637,0,105,1,512,21202,-2,-1,-2,22201,-4,-2,-4,109,-5,2105,1,0"
	dataS := strings.Split(input, ",")

	var data = make([]int64, len(dataS)*10)
	for idx, elem := range dataS {
		i, err := strconv.ParseInt(elem, 10, 64)
		if err != nil {
			log.Fatal("unable to parse int")
		}
		data[idx] = i
	}

	// initilize hull - everything is 0

	hull := make(map[pos]int64)
	p := pos{0, 0}
	d := dir{-1, 0}
	painted := make(map[pos]bool)

	inC := make(chan int64, 5)
	outC := make(chan computer.Output, 50)
	emulator := computer.NewEmulator(data, inC, outC, false)

	// part 1 starts on black (0), part 2 starts on white(1)
	inC <- 1
	maxX, maxY := 0, 0
	go func() {
		emulator.Execute()
	}()

	done := false
	for !done {
		//print(hull, p, d)
		o := <-outC
		if o.Done {
			log.Printf("emulator terminated")
			done = true
		} else {
			hull[p] = o.Val
			painted[p] = true
			if turn := <-outC; turn.Val == 0 {
				//fmt.Printf("Paint %v %v turn left\n", p, o)
				d = d.turnLeft()
			} else {
				//fmt.Printf("Paint %v %v turn right\n", p, o)
				d = d.turnRight()
			}
			p.move(d)
			if p.x >= maxX {
				maxX = p.x
			}
			if p.y >= maxY {
				maxY = p.y
			}
			inC <- hull[p]
		}
	}

	log.Printf("Painted %v panels", len(painted))

	for r := 0; r <= maxX; r++ {
		for c := 0; c <= maxY; c++ {
			if hull[pos{r, c}] == 0 {
				fmt.Print(" ")
			} else {
				fmt.Print("#")
			}
		}
		fmt.Printf("\n")
	}

	close(outC)
	close(inC)
}
